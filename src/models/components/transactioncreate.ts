/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  Airline,
  Airline$inboundSchema,
  Airline$Outbound,
  Airline$outboundSchema,
} from "./airline.js";
import {
  ApplePayPaymentMethodCreate,
  ApplePayPaymentMethodCreate$inboundSchema,
  ApplePayPaymentMethodCreate$Outbound,
  ApplePayPaymentMethodCreate$outboundSchema,
} from "./applepaypaymentmethodcreate.js";
import {
  BrowserInfo,
  BrowserInfo$inboundSchema,
  BrowserInfo$Outbound,
  BrowserInfo$outboundSchema,
} from "./browserinfo.js";
import {
  CardWithUrlPaymentMethodCreate,
  CardWithUrlPaymentMethodCreate$inboundSchema,
  CardWithUrlPaymentMethodCreate$Outbound,
  CardWithUrlPaymentMethodCreate$outboundSchema,
} from "./cardwithurlpaymentmethodcreate.js";
import {
  CartItem,
  CartItem$inboundSchema,
  CartItem$Outbound,
  CartItem$outboundSchema,
} from "./cartitem.js";
import {
  CheckoutSessionWithUrlPaymentMethodCreate,
  CheckoutSessionWithUrlPaymentMethodCreate$inboundSchema,
  CheckoutSessionWithUrlPaymentMethodCreate$Outbound,
  CheckoutSessionWithUrlPaymentMethodCreate$outboundSchema,
} from "./checkoutsessionwithurlpaymentmethodcreate.js";
import {
  ClickToPayFPANPaymentMethodCreate,
  ClickToPayFPANPaymentMethodCreate$inboundSchema,
  ClickToPayFPANPaymentMethodCreate$Outbound,
  ClickToPayFPANPaymentMethodCreate$outboundSchema,
} from "./clicktopayfpanpaymentmethodcreate.js";
import {
  ClickToPayPaymentMethodCreate,
  ClickToPayPaymentMethodCreate$inboundSchema,
  ClickToPayPaymentMethodCreate$Outbound,
  ClickToPayPaymentMethodCreate$outboundSchema,
} from "./clicktopaypaymentmethodcreate.js";
import {
  GiftCardTokenTransactionCreate,
  GiftCardTokenTransactionCreate$inboundSchema,
  GiftCardTokenTransactionCreate$Outbound,
  GiftCardTokenTransactionCreate$outboundSchema,
} from "./giftcardtokentransactioncreate.js";
import {
  GiftCardTransactionCreate,
  GiftCardTransactionCreate$inboundSchema,
  GiftCardTransactionCreate$Outbound,
  GiftCardTransactionCreate$outboundSchema,
} from "./giftcardtransactioncreate.js";
import {
  GooglePayFPANPaymentMethodCreate,
  GooglePayFPANPaymentMethodCreate$inboundSchema,
  GooglePayFPANPaymentMethodCreate$Outbound,
  GooglePayFPANPaymentMethodCreate$outboundSchema,
} from "./googlepayfpanpaymentmethodcreate.js";
import {
  GooglePayPaymentMethodCreate,
  GooglePayPaymentMethodCreate$inboundSchema,
  GooglePayPaymentMethodCreate$Outbound,
  GooglePayPaymentMethodCreate$outboundSchema,
} from "./googlepaypaymentmethodcreate.js";
import {
  GuestBuyerInput,
  GuestBuyerInput$inboundSchema,
  GuestBuyerInput$Outbound,
  GuestBuyerInput$outboundSchema,
} from "./guestbuyerinput.js";
import {
  NetworkTokenPaymentMethodCreate,
  NetworkTokenPaymentMethodCreate$inboundSchema,
  NetworkTokenPaymentMethodCreate$Outbound,
  NetworkTokenPaymentMethodCreate$outboundSchema,
} from "./networktokenpaymentmethodcreate.js";
import {
  Recipient,
  Recipient$inboundSchema,
  Recipient$Outbound,
  Recipient$outboundSchema,
} from "./recipient.js";
import {
  RedirectPaymentMethodCreate,
  RedirectPaymentMethodCreate$inboundSchema,
  RedirectPaymentMethodCreate$Outbound,
  RedirectPaymentMethodCreate$outboundSchema,
} from "./redirectpaymentmethodcreate.js";
import {
  StatementDescriptor,
  StatementDescriptor$inboundSchema,
  StatementDescriptor$Outbound,
  StatementDescriptor$outboundSchema,
} from "./statementdescriptor.js";
import {
  ThreeDSecureDataV1,
  ThreeDSecureDataV1$inboundSchema,
  ThreeDSecureDataV1$Outbound,
  ThreeDSecureDataV1$outboundSchema,
} from "./threedsecuredatav1.js";
import {
  ThreeDSecureDataV2,
  ThreeDSecureDataV2$inboundSchema,
  ThreeDSecureDataV2$Outbound,
  ThreeDSecureDataV2$outboundSchema,
} from "./threedsecuredatav2.js";
import {
  TokenPaymentMethodCreate,
  TokenPaymentMethodCreate$inboundSchema,
  TokenPaymentMethodCreate$Outbound,
  TokenPaymentMethodCreate$outboundSchema,
} from "./tokenpaymentmethodcreate.js";
import {
  TransactionIntent,
  TransactionIntent$inboundSchema,
  TransactionIntent$outboundSchema,
} from "./transactionintent.js";
import {
  TransactionPaymentSource,
  TransactionPaymentSource$inboundSchema,
  TransactionPaymentSource$outboundSchema,
} from "./transactionpaymentsource.js";

/**
 * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
 */
export type TransactionCreatePaymentMethod =
  | RedirectPaymentMethodCreate
  | ClickToPayPaymentMethodCreate
  | ClickToPayFPANPaymentMethodCreate
  | GooglePayFPANPaymentMethodCreate
  | NetworkTokenPaymentMethodCreate
  | CardWithUrlPaymentMethodCreate
  | ApplePayPaymentMethodCreate
  | GooglePayPaymentMethodCreate
  | TokenPaymentMethodCreate
  | CheckoutSessionWithUrlPaymentMethodCreate;

export type TransactionCreateGiftCards =
  | GiftCardTransactionCreate
  | GiftCardTokenTransactionCreate;

/**
 * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
 */
export type ThreeDSecureData = ThreeDSecureDataV1 | ThreeDSecureDataV2;

export type TransactionCreate = {
  /**
   * The monetary amount for this transaction, in the smallest currency unit for the given currency, for example `1299` cents to create an authorization for `$12.99`. If the `intent` is set to `capture`, an amount greater than zero must be supplied. All gift card amounts are subtracted from this amount before the remainder is charged to the provided `payment_method`.
   */
  amount: number;
  /**
   * A supported ISO 4217 currency code. For redirect requests, this value must match the one specified for `currency` in `payment_method`.
   */
  currency: string;
  /**
   * The 2-letter ISO code of the country where the transaction is processed. This is also used to filter the payment services that can process the transaction. If this value is provided for redirect requests and it's not `null`, it must match the one specified for `country` in `payment_method`. Otherwise, the value specified for `country` in `payment_method` will be assumed implicitly.
   */
  country?: string | null | undefined;
  /**
   * The optional payment method to use for this transaction. This field is required if no `gift_cards` have been added.
   */
  paymentMethod?:
    | RedirectPaymentMethodCreate
    | ClickToPayPaymentMethodCreate
    | ClickToPayFPANPaymentMethodCreate
    | GooglePayFPANPaymentMethodCreate
    | NetworkTokenPaymentMethodCreate
    | CardWithUrlPaymentMethodCreate
    | ApplePayPaymentMethodCreate
    | GooglePayPaymentMethodCreate
    | TokenPaymentMethodCreate
    | CheckoutSessionWithUrlPaymentMethodCreate
    | null
    | undefined;
  /**
   * Guest buyer details provided inline rather than creating a buyer resource beforehand and using the `buyer_id` or `buyer_external_identifier` keys. No buyer resource will be created on Gr4vy when used.
   */
  buyer?: GuestBuyerInput | null | undefined;
  /**
   * The ID of the buyer to associate this payment method to. If this field is provided then the `buyer_external_identifier` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
   */
  buyerId?: string | null | undefined;
  /**
   * The `external_identifier` of the buyer to associate this payment method to. If this field is provided then the `buyer_id` field needs to be unset. If a stored payment method or gift card is provided, then the buyer for that payment method needs to match the buyer for this field.
   */
  buyerExternalIdentifier?: string | null | undefined;
  /**
   * The optional gift card(s) to use for this transaction. At least one gift card is required if no other `payment_method` has been added. By default, only a maximum limit of 10 gift cards may be used in a single transaction. Please contact our team to change this limit.
   */
  giftCards?:
    | Array<GiftCardTransactionCreate | GiftCardTokenTransactionCreate>
    | null
    | undefined;
  /**
   * An external identifier that can be used to match the transaction against your own records.
   */
  externalIdentifier?: string | null | undefined;
  intent?: TransactionIntent | undefined;
  /**
   *  Whether or not to also try and store the payment method with us so that it can be used again for future use. This is only supported for payment methods that support this feature. There are also a few restrictions on how the flag may be set:
   *
   * @remarks
   *
   * * The flag has to be set to `true` when the `payment_source` is set to `recurring` or `installment`, and `merchant_initiated` is set to `false`.
   * * The flag has to be set to `false` (or not set) when using a previously vaulted payment method.
   */
  store?: boolean | undefined;
  /**
   * Pass through 3-D Secure data to support external 3-D Secure authorisation. If using an external 3-D Secure provider, you should not pass a `redirect_url` in the `payment_method` object for a transaction.
   */
  threeDSecureData?: ThreeDSecureDataV1 | ThreeDSecureDataV2 | null | undefined;
  /**
   * Any additional information about the transaction that you would like to store as key-value pairs. This data is passed to payment service providers that support it.
   */
  metadata?: { [k: string]: string } | null | undefined;
  /**
   * Indicates whether the transaction represents a subsequent payment coming from a setup recurring payment. Please note there are some restrictions on how this flag may be used.
   *
   * @remarks
   *
   * The flag can only be `false` (or not set) when the transaction meets one of the following criteria:
   *
   * * It is not `merchant_initiated`.
   * * `payment_source` is set to `card_on_file`.
   *
   * The flag can only be set to `true` when the transaction meets one of the following criteria:
   * * It is not `merchant_initiated`.
   * * `payment_source` is set to `recurring` or `installment` and `merchant_initiated` is set to `true`.
   * * `payment_source` is set to `card_on_file`.
   */
  isSubsequentPayment?: boolean | undefined;
  /**
   * Indicates whether the transaction was initiated by the merchant (true) or customer (false).
   */
  merchantInitiated?: boolean | undefined;
  /**
   * The way payment method information made it to this transaction.
   */
  paymentSource?: TransactionPaymentSource | undefined;
  /**
   * The airline addendum data which describes the airline booking associated with this transaction.
   */
  airline?: Airline | null | undefined;
  /**
   * An array of cart items that represents the line items of a transaction.
   */
  cartItems?: Array<CartItem> | null | undefined;
  /**
   * Details about the payment and the merchant which may end up on the (bank) statement for the payment.
   */
  statementDescriptor?: StatementDescriptor | null | undefined;
  /**
   * A scheme's transaction identifier to use in connecting a merchant initiated transaction to a previous customer initiated transaction. If not provided, and a qualifying customer initiated transaction has been previously made with the stored payment method, then Gr4vy will populate this value with the identifier returned for that transaction. This field is also know as the Visa Transaction Identifier, or Mastercard Trace ID.
   */
  previousSchemeTransactionId?: string | null | undefined;
  /**
   * Information about the browser used by the buyer. This can be used by anti-fraud services.
   */
  browserInfo?: BrowserInfo | null | undefined;
  /**
   * The unique identifier of a set of shipping details stored for the buyer. If provided, the created transaction will include a copy of the details at the point of transaction creation; i.e. it will not be affected by later changes to the detail in the database.
   */
  shippingDetailsId?: string | null | undefined;
  /**
   * Allows for passing optional configuration per connection to take advantage of connection specific features. When provided, the data is only passed to the target connection type to prevent sharing configuration across connections. Please note that each of the keys this object are in kebab-case, for example `cybersource-anti-fraud` as they represent the ID of the connector. All the other keys will be snake case, for example `merchant_defined_data` or camel case to match an external API that the connector uses.
   */
  connectionOptions?: { [k: string]: { [k: string]: any } } | null | undefined;
  /**
   * Whether to capture the transaction asynchronously.
   *
   * @remarks
   *
   * - When `async_capture` is `false` (default), the transaction is captured in the same request.
   * - When `async_capture` is `true`, the transaction is automatically captured at a later time.
   *
   * Redirect transactions are not affected by this flag. This flag can only be set to `true` when `intent` is set to `capture`.
   */
  asyncCapture?: boolean | undefined;
  /**
   * This field represents the fingerprint data to be passed to the active anti-fraud service.
   */
  antiFraudFingerprint?: string | null | undefined;
  /**
   * The unique identifier of an existing payment service. When provided, the created transaction will be processed by the given payment service and any routing rules will be skipped.
   */
  paymentServiceId?: string | null | undefined;
  /**
   * Marks the transaction as an AFT. Requires the payment service to support this feature, and might `recipient` and `buyer` data
   */
  accountFundingTransaction?: boolean | undefined;
  /**
   * Defines if the transaction will allow for a partial authorization.
   */
  allowPartialAuthorization?: boolean | undefined;
  /**
   * The recipient of any account to account funding. For use with AFTs.
   */
  recipient?: Recipient | null | undefined;
};

/** @internal */
export const TransactionCreatePaymentMethod$inboundSchema: z.ZodType<
  TransactionCreatePaymentMethod,
  z.ZodTypeDef,
  unknown
> = z.union([
  RedirectPaymentMethodCreate$inboundSchema,
  ClickToPayPaymentMethodCreate$inboundSchema,
  ClickToPayFPANPaymentMethodCreate$inboundSchema,
  GooglePayFPANPaymentMethodCreate$inboundSchema,
  NetworkTokenPaymentMethodCreate$inboundSchema,
  CardWithUrlPaymentMethodCreate$inboundSchema,
  ApplePayPaymentMethodCreate$inboundSchema,
  GooglePayPaymentMethodCreate$inboundSchema,
  TokenPaymentMethodCreate$inboundSchema,
  CheckoutSessionWithUrlPaymentMethodCreate$inboundSchema,
]);

/** @internal */
export type TransactionCreatePaymentMethod$Outbound =
  | RedirectPaymentMethodCreate$Outbound
  | ClickToPayPaymentMethodCreate$Outbound
  | ClickToPayFPANPaymentMethodCreate$Outbound
  | GooglePayFPANPaymentMethodCreate$Outbound
  | NetworkTokenPaymentMethodCreate$Outbound
  | CardWithUrlPaymentMethodCreate$Outbound
  | ApplePayPaymentMethodCreate$Outbound
  | GooglePayPaymentMethodCreate$Outbound
  | TokenPaymentMethodCreate$Outbound
  | CheckoutSessionWithUrlPaymentMethodCreate$Outbound;

/** @internal */
export const TransactionCreatePaymentMethod$outboundSchema: z.ZodType<
  TransactionCreatePaymentMethod$Outbound,
  z.ZodTypeDef,
  TransactionCreatePaymentMethod
> = z.union([
  RedirectPaymentMethodCreate$outboundSchema,
  ClickToPayPaymentMethodCreate$outboundSchema,
  ClickToPayFPANPaymentMethodCreate$outboundSchema,
  GooglePayFPANPaymentMethodCreate$outboundSchema,
  NetworkTokenPaymentMethodCreate$outboundSchema,
  CardWithUrlPaymentMethodCreate$outboundSchema,
  ApplePayPaymentMethodCreate$outboundSchema,
  GooglePayPaymentMethodCreate$outboundSchema,
  TokenPaymentMethodCreate$outboundSchema,
  CheckoutSessionWithUrlPaymentMethodCreate$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionCreatePaymentMethod$ {
  /** @deprecated use `TransactionCreatePaymentMethod$inboundSchema` instead. */
  export const inboundSchema = TransactionCreatePaymentMethod$inboundSchema;
  /** @deprecated use `TransactionCreatePaymentMethod$outboundSchema` instead. */
  export const outboundSchema = TransactionCreatePaymentMethod$outboundSchema;
  /** @deprecated use `TransactionCreatePaymentMethod$Outbound` instead. */
  export type Outbound = TransactionCreatePaymentMethod$Outbound;
}

export function transactionCreatePaymentMethodToJSON(
  transactionCreatePaymentMethod: TransactionCreatePaymentMethod,
): string {
  return JSON.stringify(
    TransactionCreatePaymentMethod$outboundSchema.parse(
      transactionCreatePaymentMethod,
    ),
  );
}

export function transactionCreatePaymentMethodFromJSON(
  jsonString: string,
): SafeParseResult<TransactionCreatePaymentMethod, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransactionCreatePaymentMethod$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransactionCreatePaymentMethod' from JSON`,
  );
}

/** @internal */
export const TransactionCreateGiftCards$inboundSchema: z.ZodType<
  TransactionCreateGiftCards,
  z.ZodTypeDef,
  unknown
> = z.union([
  GiftCardTransactionCreate$inboundSchema,
  GiftCardTokenTransactionCreate$inboundSchema,
]);

/** @internal */
export type TransactionCreateGiftCards$Outbound =
  | GiftCardTransactionCreate$Outbound
  | GiftCardTokenTransactionCreate$Outbound;

/** @internal */
export const TransactionCreateGiftCards$outboundSchema: z.ZodType<
  TransactionCreateGiftCards$Outbound,
  z.ZodTypeDef,
  TransactionCreateGiftCards
> = z.union([
  GiftCardTransactionCreate$outboundSchema,
  GiftCardTokenTransactionCreate$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionCreateGiftCards$ {
  /** @deprecated use `TransactionCreateGiftCards$inboundSchema` instead. */
  export const inboundSchema = TransactionCreateGiftCards$inboundSchema;
  /** @deprecated use `TransactionCreateGiftCards$outboundSchema` instead. */
  export const outboundSchema = TransactionCreateGiftCards$outboundSchema;
  /** @deprecated use `TransactionCreateGiftCards$Outbound` instead. */
  export type Outbound = TransactionCreateGiftCards$Outbound;
}

export function transactionCreateGiftCardsToJSON(
  transactionCreateGiftCards: TransactionCreateGiftCards,
): string {
  return JSON.stringify(
    TransactionCreateGiftCards$outboundSchema.parse(transactionCreateGiftCards),
  );
}

export function transactionCreateGiftCardsFromJSON(
  jsonString: string,
): SafeParseResult<TransactionCreateGiftCards, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransactionCreateGiftCards$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransactionCreateGiftCards' from JSON`,
  );
}

/** @internal */
export const ThreeDSecureData$inboundSchema: z.ZodType<
  ThreeDSecureData,
  z.ZodTypeDef,
  unknown
> = z.union([
  ThreeDSecureDataV1$inboundSchema,
  ThreeDSecureDataV2$inboundSchema,
]);

/** @internal */
export type ThreeDSecureData$Outbound =
  | ThreeDSecureDataV1$Outbound
  | ThreeDSecureDataV2$Outbound;

/** @internal */
export const ThreeDSecureData$outboundSchema: z.ZodType<
  ThreeDSecureData$Outbound,
  z.ZodTypeDef,
  ThreeDSecureData
> = z.union([
  ThreeDSecureDataV1$outboundSchema,
  ThreeDSecureDataV2$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ThreeDSecureData$ {
  /** @deprecated use `ThreeDSecureData$inboundSchema` instead. */
  export const inboundSchema = ThreeDSecureData$inboundSchema;
  /** @deprecated use `ThreeDSecureData$outboundSchema` instead. */
  export const outboundSchema = ThreeDSecureData$outboundSchema;
  /** @deprecated use `ThreeDSecureData$Outbound` instead. */
  export type Outbound = ThreeDSecureData$Outbound;
}

export function threeDSecureDataToJSON(
  threeDSecureData: ThreeDSecureData,
): string {
  return JSON.stringify(
    ThreeDSecureData$outboundSchema.parse(threeDSecureData),
  );
}

export function threeDSecureDataFromJSON(
  jsonString: string,
): SafeParseResult<ThreeDSecureData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ThreeDSecureData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ThreeDSecureData' from JSON`,
  );
}

/** @internal */
export const TransactionCreate$inboundSchema: z.ZodType<
  TransactionCreate,
  z.ZodTypeDef,
  unknown
> = z.object({
  amount: z.number().int(),
  currency: z.string(),
  country: z.nullable(z.string()).optional(),
  payment_method: z.nullable(
    z.union([
      RedirectPaymentMethodCreate$inboundSchema,
      ClickToPayPaymentMethodCreate$inboundSchema,
      ClickToPayFPANPaymentMethodCreate$inboundSchema,
      GooglePayFPANPaymentMethodCreate$inboundSchema,
      NetworkTokenPaymentMethodCreate$inboundSchema,
      CardWithUrlPaymentMethodCreate$inboundSchema,
      ApplePayPaymentMethodCreate$inboundSchema,
      GooglePayPaymentMethodCreate$inboundSchema,
      TokenPaymentMethodCreate$inboundSchema,
      CheckoutSessionWithUrlPaymentMethodCreate$inboundSchema,
    ]),
  ).optional(),
  buyer: z.nullable(GuestBuyerInput$inboundSchema).optional(),
  buyer_id: z.nullable(z.string()).optional(),
  buyer_external_identifier: z.nullable(z.string()).optional(),
  gift_cards: z.nullable(
    z.array(
      z.union([
        GiftCardTransactionCreate$inboundSchema,
        GiftCardTokenTransactionCreate$inboundSchema,
      ]),
    ),
  ).optional(),
  external_identifier: z.nullable(z.string()).optional(),
  intent: TransactionIntent$inboundSchema.optional(),
  store: z.boolean().default(false),
  three_d_secure_data: z.nullable(
    z.union([
      ThreeDSecureDataV1$inboundSchema,
      ThreeDSecureDataV2$inboundSchema,
    ]),
  ).optional(),
  metadata: z.nullable(z.record(z.string())).optional(),
  is_subsequent_payment: z.boolean().default(false),
  merchant_initiated: z.boolean().default(false),
  payment_source: TransactionPaymentSource$inboundSchema.optional(),
  airline: z.nullable(Airline$inboundSchema).optional(),
  cart_items: z.nullable(z.array(CartItem$inboundSchema)).optional(),
  statement_descriptor: z.nullable(StatementDescriptor$inboundSchema)
    .optional(),
  previous_scheme_transaction_id: z.nullable(z.string()).optional(),
  browser_info: z.nullable(BrowserInfo$inboundSchema).optional(),
  shipping_details_id: z.nullable(z.string()).optional(),
  connection_options: z.nullable(z.record(z.record(z.any()))).optional(),
  async_capture: z.boolean().default(false),
  anti_fraud_fingerprint: z.nullable(z.string()).optional(),
  payment_service_id: z.nullable(z.string()).optional(),
  account_funding_transaction: z.boolean().default(false),
  allow_partial_authorization: z.boolean().default(false),
  recipient: z.nullable(Recipient$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "payment_method": "paymentMethod",
    "buyer_id": "buyerId",
    "buyer_external_identifier": "buyerExternalIdentifier",
    "gift_cards": "giftCards",
    "external_identifier": "externalIdentifier",
    "three_d_secure_data": "threeDSecureData",
    "is_subsequent_payment": "isSubsequentPayment",
    "merchant_initiated": "merchantInitiated",
    "payment_source": "paymentSource",
    "cart_items": "cartItems",
    "statement_descriptor": "statementDescriptor",
    "previous_scheme_transaction_id": "previousSchemeTransactionId",
    "browser_info": "browserInfo",
    "shipping_details_id": "shippingDetailsId",
    "connection_options": "connectionOptions",
    "async_capture": "asyncCapture",
    "anti_fraud_fingerprint": "antiFraudFingerprint",
    "payment_service_id": "paymentServiceId",
    "account_funding_transaction": "accountFundingTransaction",
    "allow_partial_authorization": "allowPartialAuthorization",
  });
});

/** @internal */
export type TransactionCreate$Outbound = {
  amount: number;
  currency: string;
  country?: string | null | undefined;
  payment_method?:
    | RedirectPaymentMethodCreate$Outbound
    | ClickToPayPaymentMethodCreate$Outbound
    | ClickToPayFPANPaymentMethodCreate$Outbound
    | GooglePayFPANPaymentMethodCreate$Outbound
    | NetworkTokenPaymentMethodCreate$Outbound
    | CardWithUrlPaymentMethodCreate$Outbound
    | ApplePayPaymentMethodCreate$Outbound
    | GooglePayPaymentMethodCreate$Outbound
    | TokenPaymentMethodCreate$Outbound
    | CheckoutSessionWithUrlPaymentMethodCreate$Outbound
    | null
    | undefined;
  buyer?: GuestBuyerInput$Outbound | null | undefined;
  buyer_id?: string | null | undefined;
  buyer_external_identifier?: string | null | undefined;
  gift_cards?:
    | Array<
      | GiftCardTransactionCreate$Outbound
      | GiftCardTokenTransactionCreate$Outbound
    >
    | null
    | undefined;
  external_identifier?: string | null | undefined;
  intent?: string | undefined;
  store: boolean;
  three_d_secure_data?:
    | ThreeDSecureDataV1$Outbound
    | ThreeDSecureDataV2$Outbound
    | null
    | undefined;
  metadata?: { [k: string]: string } | null | undefined;
  is_subsequent_payment: boolean;
  merchant_initiated: boolean;
  payment_source?: string | undefined;
  airline?: Airline$Outbound | null | undefined;
  cart_items?: Array<CartItem$Outbound> | null | undefined;
  statement_descriptor?: StatementDescriptor$Outbound | null | undefined;
  previous_scheme_transaction_id?: string | null | undefined;
  browser_info?: BrowserInfo$Outbound | null | undefined;
  shipping_details_id?: string | null | undefined;
  connection_options?: { [k: string]: { [k: string]: any } } | null | undefined;
  async_capture: boolean;
  anti_fraud_fingerprint?: string | null | undefined;
  payment_service_id?: string | null | undefined;
  account_funding_transaction: boolean;
  allow_partial_authorization: boolean;
  recipient?: Recipient$Outbound | null | undefined;
};

/** @internal */
export const TransactionCreate$outboundSchema: z.ZodType<
  TransactionCreate$Outbound,
  z.ZodTypeDef,
  TransactionCreate
> = z.object({
  amount: z.number().int(),
  currency: z.string(),
  country: z.nullable(z.string()).optional(),
  paymentMethod: z.nullable(
    z.union([
      RedirectPaymentMethodCreate$outboundSchema,
      ClickToPayPaymentMethodCreate$outboundSchema,
      ClickToPayFPANPaymentMethodCreate$outboundSchema,
      GooglePayFPANPaymentMethodCreate$outboundSchema,
      NetworkTokenPaymentMethodCreate$outboundSchema,
      CardWithUrlPaymentMethodCreate$outboundSchema,
      ApplePayPaymentMethodCreate$outboundSchema,
      GooglePayPaymentMethodCreate$outboundSchema,
      TokenPaymentMethodCreate$outboundSchema,
      CheckoutSessionWithUrlPaymentMethodCreate$outboundSchema,
    ]),
  ).optional(),
  buyer: z.nullable(GuestBuyerInput$outboundSchema).optional(),
  buyerId: z.nullable(z.string()).optional(),
  buyerExternalIdentifier: z.nullable(z.string()).optional(),
  giftCards: z.nullable(
    z.array(
      z.union([
        GiftCardTransactionCreate$outboundSchema,
        GiftCardTokenTransactionCreate$outboundSchema,
      ]),
    ),
  ).optional(),
  externalIdentifier: z.nullable(z.string()).optional(),
  intent: TransactionIntent$outboundSchema.optional(),
  store: z.boolean().default(false),
  threeDSecureData: z.nullable(
    z.union([
      ThreeDSecureDataV1$outboundSchema,
      ThreeDSecureDataV2$outboundSchema,
    ]),
  ).optional(),
  metadata: z.nullable(z.record(z.string())).optional(),
  isSubsequentPayment: z.boolean().default(false),
  merchantInitiated: z.boolean().default(false),
  paymentSource: TransactionPaymentSource$outboundSchema.optional(),
  airline: z.nullable(Airline$outboundSchema).optional(),
  cartItems: z.nullable(z.array(CartItem$outboundSchema)).optional(),
  statementDescriptor: z.nullable(StatementDescriptor$outboundSchema)
    .optional(),
  previousSchemeTransactionId: z.nullable(z.string()).optional(),
  browserInfo: z.nullable(BrowserInfo$outboundSchema).optional(),
  shippingDetailsId: z.nullable(z.string()).optional(),
  connectionOptions: z.nullable(z.record(z.record(z.any()))).optional(),
  asyncCapture: z.boolean().default(false),
  antiFraudFingerprint: z.nullable(z.string()).optional(),
  paymentServiceId: z.nullable(z.string()).optional(),
  accountFundingTransaction: z.boolean().default(false),
  allowPartialAuthorization: z.boolean().default(false),
  recipient: z.nullable(Recipient$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    paymentMethod: "payment_method",
    buyerId: "buyer_id",
    buyerExternalIdentifier: "buyer_external_identifier",
    giftCards: "gift_cards",
    externalIdentifier: "external_identifier",
    threeDSecureData: "three_d_secure_data",
    isSubsequentPayment: "is_subsequent_payment",
    merchantInitiated: "merchant_initiated",
    paymentSource: "payment_source",
    cartItems: "cart_items",
    statementDescriptor: "statement_descriptor",
    previousSchemeTransactionId: "previous_scheme_transaction_id",
    browserInfo: "browser_info",
    shippingDetailsId: "shipping_details_id",
    connectionOptions: "connection_options",
    asyncCapture: "async_capture",
    antiFraudFingerprint: "anti_fraud_fingerprint",
    paymentServiceId: "payment_service_id",
    accountFundingTransaction: "account_funding_transaction",
    allowPartialAuthorization: "allow_partial_authorization",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TransactionCreate$ {
  /** @deprecated use `TransactionCreate$inboundSchema` instead. */
  export const inboundSchema = TransactionCreate$inboundSchema;
  /** @deprecated use `TransactionCreate$outboundSchema` instead. */
  export const outboundSchema = TransactionCreate$outboundSchema;
  /** @deprecated use `TransactionCreate$Outbound` instead. */
  export type Outbound = TransactionCreate$Outbound;
}

export function transactionCreateToJSON(
  transactionCreate: TransactionCreate,
): string {
  return JSON.stringify(
    TransactionCreate$outboundSchema.parse(transactionCreate),
  );
}

export function transactionCreateFromJSON(
  jsonString: string,
): SafeParseResult<TransactionCreate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransactionCreate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransactionCreate' from JSON`,
  );
}
